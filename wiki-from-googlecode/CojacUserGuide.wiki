#summary COJAC User Guide
#labels Featured
*Contents*
<wiki:toc max_depth="1"/>
--------------------------------------------------
= 1. Introduction =

COJAC is a tool to detect anomalies during arithmetic operations in Java code, 
involving either integers or floating point numbers. You can apply it on your 
own code to detect vicious bugs that aren't detected by the Java Virtual 
Machine. This tool is provided as a new JVM option, allowing you to launch 
any Java application with COJAC. 

With COJAC you don't have to modify your source code or even recompile it. All 
the work is done at runtime, when your application gets instrumented on-the-fly. 

COJAC is highly configurable, you can specify which operations are to be 
watched and how you want COJAC to warn you about the problems. 

COJAC is offered (without warranty of course) in the hope it can be useful 
for educational purposes, as well as in the software industry.

Any comment/feedback is welcome! 
(use [http://groups.google.com/group/cojac-discuss]).

You might be interested in the accompanying [EclipsePlugin Eclipse plugin], 
as well as in the valgrind-based cousin 
[http://code.google.com/p/cojac-grind/ cojac-grind].

The general concept of "numerical problem sniffer" is presented in our 
[http://drdobbs.com/testing/232601564# article] published by Dr Dobb's.


--------------------------------------------------
= 2. Launching an application with COJAC =

With the new release, the recommended way of using COJAC relies on the Java 
Agent mechanism, via the mere insertion of the following JVM option:

{{{
-javaagent:cojac.jar[=cojac_options] 
}}}

The -javaagent JVM option lets you seamlessly activate COJAC at runtime. 
For instance:

{{{
java -javaagent:cojac-1.1.jar -jar MyApplication.jar
java -javaagent:cojac-1.1.jar="-d -f -s" -cp myFolder my.pkg.MyMain
}}}

It should be widely applicable (applications, servlets, junit test case, from 
within an IDE...). 

== 2.2 Launching a JAR, the old way (DEPRECATED!) ==

{{{
Without COJAC: java -jar           [--] Application.jar [args...]
With COJAC:    java -jar cojac.jar [--] Application.jar [args...]
}}}

The `--` is mandatory only if the parameters of your application might conflict 
with one of the Cojac options. 

== 2.3 Launching a class, the old way (DEPRECATED!) ==

If you want to launch a class directly, you have to take care of the classpath: 

{{{
Without COJAC: java                [-classpath ...] [--] org.simple.MainClass [args...]
With COJAC:    java -jar cojac.jar [-classpath ...] [--] org.simple.MainClass [args...]
}}}

The `-classpath` (or `-cp`) options plays the same role as in the JVM, 
but it is required to place it *after* cojac.jar (like the other Cojac options).

--------------------------------------------------
= 3. What COJAC considers suspicious= 

 * *Integer overflow*: the result is out-of-bounds for a `long` or `int` operation (an arithmetic operation, not the bit-shift operations). Examples: `3*Integer.MAX_VALUE, Integer.MIN_VALUE/-1`
 * *Offending typecasting*: a value loses its essence after a type conversion. Examples: `(int) Long.MAX_VALUE, (int) Float.NaN`
 * *Smearing*:  adding/subtracting a non-zero floating point number (float or double) has no effect because the two operands have excessively different orders of magnitude. Examples: `(342.0 + 1.0E-43), (342.0 - 1.0E+43)`
 * *Cancellation*: two floating point numbers almost cancel each other after an addition or subtraction, so that the least significant bits (often noise) are promoted to highest significance. Example:  `(3.000001f - 3.0f)`
 * *Questionable comparisons*: two floating point numbers are being compared, but they are very close together. Example: `if (3.000001f == 3.0f)...`
 * *Underflow*: the result of a division is so small that it gets rounded to zero. Example: `(2.5E-233 / 7.2E+233)`
 
Note that all these examples, if they are written in Java like this, 
are evaluated at compile-time because they involve only literal values. 
See [CojacUserGuide#10._Known_issues].
--------------------------------------------------
= 4. Configuring what COJAC will detect =

COJAC offers a fine-grained configuration of what must be instrumented in the application; the options let you select which category (or even which bytecode instructions) to watch:

 * *`-a`* Activates all possible detectors (this is the default behaviour)
 * *`-ints`* Watches the "int" operations: `-IADD -IDIV -IINC -ISUB -IMUL -INEG`
 * *`-longs`* Watches the "long" operations: `-LADD -LDIV -LSUB -LMUL -LNEG`
 * *`-doubles`* Watches the "double" operations: `-DADD -DDIV -DSUB -DMUL -DREM`
 * *`-floats`* Watches the "float" operations: `-FADD -FDIV -FSUB -FMUL -FREM`
 * *`-casts`*  Watches the typecasting operations: `-L2I -I2S -I2C -I2B -D2F -D2I -D2L -F2I -F2L`
 * *`-maths`*  Detects problems when invoking java.lang.Math methods, like `Math.sqrt` etc.

By default, all detectors are activated.

Cojac instrument the code everywhere, except classes of the standard library 
(`java.*`), and possibly what has been requested to be skipped with one of the
mechanisms described below.

== 4.1 Excluding some code with -b option ==

One way of preventing the instrumentation of a class is to use the `-b` 
(`--bypass`) option : 
{{{
java -javaagent:cojac.jar="-b ch.eif.;com.foo.Bar"
}}}

This will discard the instrumentation of any class whose fully qualified name
starts with "ch.eif." or "com.foo.Bar". 

== 4.2 Excluding some code with annotations ==

It is possible to exclude particular classes or methods with an annotation
in the source code. The only requirement is to add the following interface
somewhere in your code (in whatever package, but the interface identifier 
has to be strictly respected):

{{{
import java.lang.annotation.Retention;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Retention(RUNTIME)
public @interface NoCojacInstrumentation {}
}}}

The annotation is to be placed just before the class or method definition; 
its scope is local.

--------------------------------------------------
= 5. Configuring how COJAC will signal the detected problems  =

You can  choose the way COJAC will inform you when a problem occurs: 

 * *`-c`*   This is the default option, all the messages are printed to the standard error stream

 * *`-l file`*  All warning messages are appended to a file, the 'file' argument is optional, by default the file is named `COJAC_Report.log`

 * *`-e`*  Each problem will throw an `ArithmeticException`

 * *`-k methId`*   Each problem will invoke a method of your choice. The method must have that signature: `public static void f(String opcodeName)` and you have to provide its complete qualified path, in the format `pkgA/myPkg/myClass/myMethod`

You can also configure what information COJAC will give you. Use the `-d` 
option to have the detailed stack trace for each warning. You can also use 
the `-t` to display the stats about the instrumentation, namely some 
information about how many bytecode instructions have been instrumented by COJAC. 

COJAC provides a `-f` option which filters the warnings. For 
instance, if you have the same line that causes the same error many times, 
it's convenient to see only the first occurrence, this is what the -f option 
will give you. If you have enabled the -s option, all the filtered events will 
be finally synthesized (with occurrences count).  


--------------------------------------------------
= 6. Instrumenting without executing =

Early versions of COJAC were able to create "offline" an instrumented version of the 
application code (that can later be executed). We no longer provide this feature: 
COJAC is designed to apply on-the-fly instrumentation, we advocate its use
as a diagnostic-enabled java launching means. 

--------------------------------------------------
= 7. Example  =

Here is a small example of what COJAC can do. Let's take a simple class like that: 

{{{
/*01*/ public class Demo {
/*02*/   public static void main(String[] args) {
/*03*/    int a = 2000000000, b = 2000000000;
/*04*/    int res1 = a + b;
/*05*/    System.out.println("Adding billions: " + res1);
/*06*/    double c = 1E22, d = 321;
/*07*/    double res2 = c + d;
/*08*/    System.out.println("Adding units to a large number : " + res2);
/*09*/    double sqrt = Math.sqrt(-1);
/*10*/    System.out.println("Square root of -1: " + sqrt);
/*11*/  }
/*12*/}
}}}

Compile it with:

{{{
javac Demo.java
}}}

Then, use COJAC to launch this application: 

{{{
java -javaagent:cojac.jar Demo
}}}

And you'll get the following output: 

{{{
   COJAC: Overflow : IADD Demo.main(Demo.java:4)
Adding billions: -294967296
   COJAC: Smearing: DADD Demo.main(Demo.java:7)
Adding units to a large number : 1.0E22
   COJAC: Maths error (NaN) with java/lang/Math.sqrt(D)D Demo.main(Demo.java:9)
Square root of -1: NaN
}}}

You can see the warning messages in the console. All the COJAC logs start 
with ''COJAC: '', followed by the kind of anomaly and the location in 
the source code.


--------------------------------------------------
= 8. JMX feature =

COJAC now gives the developer access to detection management through JMX. 
The management interface is the following:

{{{
Map<String, Integer> getCountersMBean() // gives every opcode instrumented with statistics;
List<String>         getBlacklist() // offers the developer a means to know which methods are subject to annotation;
Map<String, Long>    getEvent() // gives every detected event that occurred since the beginning of the application;
void                 start() 
void                 stop() // let you dynamically enable or disable the processing of the detected events.
}}}

The RMI service URL is parameterized by a couple of COJAC options. Here is 
the pattern and an example of default configuration:

{{{
pattern:
service:jmx:rmi:///jndi/rmi://<host>:<port>/<MBean-name>

default: 
service:jmx:rmi:///jndi/rmi://localhost:5017/COJAC
}}}

You can access the management interface programmatically or using a tool such 
as jconsole. This can be great to watch long-term running applications or 
web services.

--------------------------------------------------
= 9. Usage =


Here is the full manpage-like description of COJAC: 

{{{
usage: java -javaagent:cojac.jar="[OPTIONS]" YourApp [appArgs]
         Or one of the old modes  (DEPRECATED!) :
       java -jar cojac.jar [OPTIONS] -- YourApp [appArgs]
       java -jar cojac.jar [OPTIONS] -i File [Files]
       The "--" is needed when appArgs conflict with Cojac options

 -a,--all                  Instrument every operation (int, long, cast, Math)
 -b,--bypass <arg>         Bypass classes starting with one of these prefixes
 -c,--console              Signal overflows with console messages to stderr (default signaling policy)
 -casts                    Activate all the casts opcodes
 -cp,--classpath <arg>     Specify the classpath (not for the java agent activation mode)
 -d,--detailed             logs the full stack trace (combined with -c or -l)
 
 -d2f -d2i -d2l -dadd -dcmp -ddiv -dmul -drem -dsub 
 -f2i -f2l -fadd -fcmp -fdiv -fmul -frem -fsub -i2b -i2c
 -i2s -iadd -idiv -iinc -imul  -ineg  -isub -l2i  
 -ladd  -ldiv  -lmul -lneg 
 -lsub                     Instrument that particular bytecode instruction
 -k,--callback <meth>      Signal overflows by calling a particular user-defined
                           method whose definition matches the following:
                             public static void f(String opcodeName)
                           Give the fully qualified method identifier, in the form:
                             pkgA/myPkg/myClass/myMethod
 -doubles                  Activate all the doubles opcodes
 -e,--exception            Signal overflows by throwing an ArithmeticException
 -f,--filter               Report each problem only once per faulty line
 -floats                   Activate all the floats opcodes
 -h,--help                 Print the help of the program
 -i,--instrument           Instrument the files (batch mode). Some options are incompatible with this mode
 -ints                     Activate all the ints opcodes
 -l,--logfile <path>       Signal overflows by writing to a log file. Default filename is: COJAC_Report.log.
 -longs                    Activate all the longs opcodes
 -maths                    Detect problems in (Strict)Math.XXX() methods
 -n,--none                 Do not instrument any instruction at all
 -p,--path <path>          Path where the instrumented code will be written. Default is .\COJAC_Output\
 -s,--summary              Print runtime statistics
 -t,--stats                Print instrumentation statistics
 -w,--withinStack          Instruments so that the checks lie directly on the stack instead of via an 
                           additional method call. This generally degrades the RAM & CPU overhead, but
                           occasionally it could be better. This option might disappear in future releases.
 -jmxenable                Enable the JMX access feature.
 -jmxhost <host>           Set the host for remote JMX connection (Default is localhost).
 -jmxport <port>           Set the port for remote JMX connection (Default is 5017).
 -jmxname <MBean-id>       Set the name of the remote MBean (Default is COJAC).
 
}}}

--------------------------------------------------
= 10. Known issues=

Here are a couple of issues for the current version of Cojac:

 * Of course a suspicious operation is not always the manifestation of a software defect. For instance, you can rely on integer overflows to compute a hash function, or maybe cancellation phenomenon is not a problem because the floating point numbers you deal with do not suffer from imprecision.

 * Cojac has been mainly tested on JVM-1.6. For JVM-1.7, it may have troubles to fulfill the constraints that the bytecode verifier now strictly considers. Using the JVM option `-XX:-UseSplitVerifier` might help. 

 * That's inherent to the approach: compile-time expressions can't be processed:
{{{
System.out.println(3*Integer.MAX_VALUE);
}}}

 * Some rare libraries can have trouble with Cojac if they make hypotheses about the classloader (e.g. the `slf4g` logging framework). Use the bypass option to skip them, e.g. `-bypass org.slf4j`. Note that such problems should not happen with the Java agent invocation mode.
 
 * The -k (callback) option may not guarantee that the callback class is loaded with the adequate classloader. Try combining with -w in case of problems. Or prefer the -javaagent way of invocation.
 
If you dream of a similar tool not limited to the Java world, have a look at [http://code.google.com/p/cojac-grind/]...

--------------------------------------------------
= 11. double/float replacement feature (experimental) =

We have been working on the automatic replacement of the primitive types float/double by richer object models. Cojac-1.3 illustrates this with an option `-BDP nDigits` that turns float/double into `BigDecimal` with a specific number of significant digits. There are still limitations, but... yes we did it!

Here is an example to show the idea: 

{{{
prompt> java HelloMrCojac
3.232315809405594
3.1425916543395442
3.1415936535887745

prompt> java -javaagent:cojac.jar="-BDP 2"   HelloMrCojac
3.3 3.3
3.3 3.3
3.3 3.3

prompt> java -javaagent:cojac.jar="-BDP 100"   HelloMrCojac
3.2323158094055926 3.232315809405592687326433456464416216738198162346769157914668750582063275561727574111475040267609927
3.142591654339543 3.142591654339543050901127737252204566153538256316955873675303860503427171619557703217696070138604748
3.141593653588793 3.141593653588793239212643133279315384134670383750090190572600838450905273472072581879999874230239464
}}}

And the corresponding code: 

{{{
public class HelloMrCojac {  

  public static String COJAC_MAGIC_DOUBLE_toStr(double n) { return ""; }
  public static String COJAC_MAGIC_DOUBLE_toStr(float  n) { return ""; }

  public static void main(String[] args) {
    double p1=approxPi(10);
    double p2=approxPi(1000);
    double p3=approxPi(1000000);
    System.out.println(p1+" "+COJAC_MAGIC_DOUBLE_toStr(p1));
    System.out.println(p2+" "+COJAC_MAGIC_DOUBLE_toStr(p2));
    System.out.println(p3+" "+COJAC_MAGIC_DOUBLE_toStr(p3));
  }
  
  public static double approxPi(long m) {
    double r = 1.0, dm, dp, k;
    for (long i=2; i<=m; i=i+2) {
      k = 2*i;
      dm = 1.0/(k-1);
      dp = 1.0/(k+1);
      r  = r - dm + dp;
    }
    return 4*r;
  }
}
}}}

We plan to explore other possible variants of this feature. 

--------------------------------------------------
Happy numerical problem sniffing!

Frederic Bapst. 