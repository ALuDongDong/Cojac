<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html><head><title>COJAC Homepage</title>

</head><body>

<!-- ------------------------------------------- -->
<h1>COJAC : Checked Overflows in JAva Code</h1>

<!-- ------------------------------------------- -->
<h2> Introduction</h2>

Cojac instruments Java bytecode so that integer overflows will be signaled
at runtime.  <br>
For example, consider the following file Abc.java :

<pre><tt>
    public class Abc {
      public static void main(String[] args) {
        int a=2, b=Integer.MAX_VALUE;
        System.out.println(a*b);
      } 
    }
</tt></pre>

<br>
Compile it, then instrument the Abc.class file with Cojac:
<tt>java -jar cojac-0.91.jar Abc.class</tt><br>
Execute the instrumented file COJAC_Output\Abc.class.<br>
It will generate at runtime a log file Abc_COJAC_Report.log saying:
<br><br><tt>
  COJAC: Overflow: IMUL Abc.main(Abc.java:4)
</tt><br>

<!-- ------------------------------------------- -->
<h2> Current Version </h2>
<a href="http://home.hefr.ch/bapst/cojac/cojac-0.91.jar">cojac-0.91.jar</a>

<!-- ------------------------------------------- -->
<h2>Usage</h2>

java -jar cojac-0.91.jar [options] ClassOrJarFilename

<!-- ------------------------------------------- -->
<h2> Basic Options </h2>

<ul>
<li> -l [fileName.log] : signal overflows by writing to a log file.
                    Default filename is: <classname>_COJAC_Report.log
                    This is the default signaling policy
</classname></li><li> -p                : signal overflows with console messages (to stderr)
</li><li> -e                : signal overflows by throwing an ArithmeticException
</li><li> -all              : instruments every operation (int, long, cast)
</li><li> -path pathName    : path where the instrumented code will be written.
                    <br>Default is .\COJAC_Output\
</li><li> -stats            : print statistics during instrumentation
</li></ul>

<h2>
Other Options
</h2>

<ul>
<li> -iadd -isub -imul 
</li><li> -idiv -iinc -ineg   : instruments that particular int operation (default)
</li><li> -ladd -lsub -lmul 
</li><li> -ldiv -lneg         : instruments that particular long operation
</li><li> -l2i -i2s -i2c -i2b : instruments that particular cast operation						

</li><li> -call method        : signals overflows by calling
                      a particular user-defined method whose definition
                      must match the following :<br>
                      <tt>public static void f(String instructionName)</tt>
                      <br>Give the fully qualified method identifier, in the form:
                        pkgA/pkgB/Class/myMethod
                                           
</li><li> -method identifier
        signature   : instruments only the specified method.
                      <br>Give the fully qualified method identifier, in the form
                        pkgA/pkgB/myClass/myMethod
                      <br>Signature conforms to Java format (as given by javap -s)
                        eg: (I[I)S for short a(int b, int [] c)


</li><li> -opsize : instruments so that the bytecode size overhead is limited
          (but the instrumented code will be slower...)
</li><li> -detailedLog : logs the full stack trace (combined with -p or -l)
</li></ul>

<!-- ------------------------------------------- -->
<h2> Ackowledgements </h2>

Thanks to Ruggero Botteon and Diego Cavadini for the enthousiasm and
efforts during their diploma project (November 2007).

<!-- ------------------------------------------- -->
<h2>Notes</h2>
<ul>
<li> No warranty... Use at your own risks
</li><li> Use only one signaling policy (either -p, -e, or -l)
</li><li> You can mix checked operations (eg -iadd -lmul -isub -i2b)
</li><li> Log file must use the .log extension
</li><li> Processed files must end with .jar or .class
</li><li> this is a first implementation. The slowdown is quite big. 
  The whole can be
  improved. The source code is getting better but still needs refactoring.
</li><li> Problems are expected with logfile signaling for a multi-thread application.
</li><li> Compile-time evaluated expression (eg (7*MAX_VALUE) ) won't be signaled... 
</li><li> Don't instrument java1.6 bytecode from within an older jvm.
</li><li> Happy Cojacing !
</li>
</ul>

<a href="http://home.hefr.ch/bapst">Frederic Bapst</a>

</div></body></html>